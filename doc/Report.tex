\documentclass[a4paper,14pt,oneside]{extreport}  %односторонняя печать
\usepackage[utf8]{inputenc}
\usepackage[russianb]{babel}
\usepackage{fontspec}
\usepackage {titlesec}
\usepackage{tocloft}
\usepackage{graphicx}
\usepackage[unicode, pdftex]{hyperref}
\graphicspath{{Desktop/}}
\DeclareGraphicsExtensions{.pdf,.png,.jpg}
\setlength{\cftbeforetoctitleskip}{-1em}

\titleformat{\chapter}{\thispagestyle{plain}\hyphenpenalty=10000\normalfont\huge\bfseries}{\thechapter. }{0pt}{\Huge}
\makeatother

\makeatletter
\renewcommand{\@makeschapterhead}[1]{\vspace{0pt}{\parindent=0pt \raggedright\normalfont\Huge\bfseries #1\par\nopagebreak\vspace{20 pt}}}
\makeatother

\titlespacing{\chapter}{0pt}{-1cm}{1.5cm}

\setmainfont{Times  New Roman}
\usepackage{vmargin}
\usepackage{amsmath}
\setpapersize{A4}
\setmarginsrb{3cm}{2cm}{1cm}{2cm}{0pt}{0mm}{0pt}{13mm} 
\usepackage{indentfirst}
\sloppy
\begin{document}
	\begin{titlepage}
		\begin{centering}
		{ МИНИСТЕРСТВА НАУКИ И ВЫСШЕГО ОБРАЗОВАНИЯ \\ РОССИЙСКОЙ ФЕДЕРАЦИИ\\Федеральное государственное автономное образовательное учреждение\\
			высшего образования «Самарский национальный исследовательский\\
			университет имени академика С.П. Королева»\\{(Самарский университет)}\\	}
      	\end{centering}
        \vfill
        \begin{table}[h]
            \begin{center}
         	\begin{tabular}{|p{2,94cm}|p{12,76cm}|}
       		\hline Институт & информатики и кибернетики \\ \hline
       		Факультет & информатики  \\ \hline
       		Кафедра & геоинформатики и информационной безопасности \\ \hline
        	\end{tabular}
            \end{center}
        \end{table}
		\centerline{\bf ЗАДАНИЕ НА КУРСОВОЙ ПРОЕКТ} 
		\vfill
		\noindent{Студентам Бобкову В.А. группы 6312, Правдину И.Д. группы 6312, \\ Терновскому Е.В. группы 6312, Хвацковой А.А. группы 6312\\}
        \noindent{«Тема проекта: Реализация отладчика для компьютерной программы»}
        \vfill
        \begin{table}[h]
          \begin{center}
          	\begin{tabular}{|p{4,5cm}|p{6cm}|p{6cm}|}
          		\hline  
          		Планируемые результаты освоения образовательной программы (компетенции) & Планируемые результаты практики & Содержание задания \\ \hline
          		ОПК-3 ‑ способность применять языки, системы и инструментальные средства программирования в профессиональной деятельности& Знать основные понятия системного программирования (операционная система, файл, поток, процесс, сигнал и др.); основные системные вызовы, описанные в стандарте POSIX; механизм осуществления системных вызовов.
          		Уметь использовать системные вызовы при написании программ.
          		Владеть навыками создания программ для операционных систем, реализующих стандарт POSIX. & 1. Изучение методов и подходов к решению задачи отладчика. \newline 2. Изучение связанных механизмов работы ОС. \newline 3. Программная реализация отладчика. \newline
          		 4. Отладка и тестирование разработанной программы. \\ \hline 
          	\end{tabular}
          \end{center}
        \end{table}
        \noindent{Дата выдачи задания 10 февраля 2022 г\\ Срок представления на кафедру пояснительной записки 9 июня 2022 г.}
    \end{titlepage}

        \setcounter{page}{2} 
      \noindent{Руководитель курсового проекта\\}
      ст. преподаватель каф. ГИиИБ \hspace{60pt} $\underset{\text{\itshape ({\small подпись})}}{\underline{\hspace{0.2\textwidth}}}$ \ А.В. Веричев\\
      Задание приняли к исполнению\\
     \\ студент группы \textnumero\ 6312 \hspace{100pt}  $\underset{\text{\itshape ({\small подпись})}}{\underline{\hspace{0.2\textwidth}}}$ \ Бобков В.А. \\
     \\ студент группы \textnumero\ 6312 \hspace{100pt} $\underset{\text{\itshape ({\small подпись})}}{\underline{\hspace{0.2\textwidth}}}$ \ Правдин И.Д.\\
     \\ студент группы \textnumero\ 6312 \hspace{100pt} $\underset{\text{\itshape ({\small подпись})}}{\underline{\hspace{0.2\textwidth}}}$ \ Терновский Е.В.\\
     \\ студент группы \textnumero\ 6312 \hspace{100pt} $\underset{\text{\itshape ({\small подпись})}}{\underline{\hspace{0.2\textwidth}}}$ \ Хвацкова А.А.
\newpage
{\bf РЕФЕРАТ}

\vskip12pt
{\bf Пояснительная записка к курсовому проекту: } {23с., 16 рисунков, 7 источников.}

 РЕАЛИЗАЦИЯ ОТЛАДЧИКА ДЛЯ КОМПЬЮТЕРНОЙ ПРОГРАММЫ\\

Цель работы: написание отладчика в операционной системе Linux с помощью языка программирования С++ с реализацией таких функций, как запуск, остановка и продолжение выполнения, установка точки останова, чтение и запись регистров и памяти, step методы и вывод исходного кода отлаживаемого приложения.

\newpage
\tableofcontents

\chapter*{Введение}
Отладчики — один из самых ценных инструментов в наборе любого разработчика. Эта компьютерная программа предназначена для поиска ошибок в других программах и ядрах операционных систем. Отладчик позволяет выполнять трассировку, отслеживать, устанавливать или изменять значения переменных в процессе выполнения кода, устанавливать и удалять точки останова.
Отладчики бывают самыми разными, на данный момент существует множество отладчиков, в которых реализуется различный функционал в зависимости от задач, языков программирования и функций, стоящих перед разработчиком. В качестве примеров популярных на данный момент отладчиков можно привести DBX, Dtrace, GNU Debugger и так далее.\\

Отладчики могут иметь два типа интерфейсов: CLI и GIU.
\begin{enumerate}
	\item CLI (command line interface) — интерфейс командной строки, при котором отладка выполняется с помощью терминала
	\item GIU (Graphic User Interface) графический пользовательский интерфейс, элементы которого выполнены в виде графических изображений. То есть все основные объекты, присутствующие в этом интерфейсе — иконки, функциональные кнопки, объекты меню и т.д. — выполнены в виде изображений.
\end{enumerate}

Стоит отметить, что на данный момент разработка такого инструмента как отладчик крайне актуальна, так как реализация любого кода или программы сильно усложняется без отладки, а нахождение различных типов ошибок в коде может занимать несколько часов или даже дней, если пренебрегать таким полезным и важным инструментом, как отладчик.

\newpage
\chapter{Выбранные технологии при разработке приложения}
\section{Язык программирования и операционная система}
Для написания отладчика был выбран язык программирования С++.
C++ компилируемый, структурированный, объектно-ориентированный, сильно упрощающий работу с большими программами. Компиляторы C++ есть на каждой операционной системе, большинство программ легко переносится с платформы на платформу. В рамках данного курсового проекта главным преимуществом С++ — нативный вызов системных функций типа ptrace.\\

В качестве платформы приложения был выбран Linux, главным преимуществом которого является системный вызов ptrace (Process Trace). Ptrace предоставляет механизм, с помощью которого родительский процесс может наблюдать и контролировать выполнение другого процесса. Он может проверять и изменять свой основной образ и регистры и используется в основном для реализации отладки точек останова и отслеживания системных вызовов.
Так как ptrace — это системный вызов использующийся исключительно в Unix-подобных системах, Linux является оптимальной операционной системой для реализации отладчика.
\section{Технология отладки}
Также для реализации курсового проекта было необходимо выбрать технологию отладки. Для этого необходимо определить какой тип точек останова будет реализован в проекте.

Есть два основных вида точек останова: программные (soft breakponit) и аппаратные (hardware breakpoint). Они ведут себя очень похоже, но выполняются очень разными способами.
\begin{enumerate}
	\item Программные точки останова
	
	Перед выполнением программа сначала загружается в память, что позволяет нам временно модифицировать участок памяти, связанный с программой, без влияния на процесс ее выполнения. Именно так и работают программные точки останова. Отладчик запоминает ассемблерную инструкцию, где должна быть вставлена точка останова, затем заменяет ее на ассемблерную инструкцию INT 3 (0xcc), которая заставляет процессор остановить выполнение программы. Как только точка останова достигнута, отладчик считывает текущий адрес памяти, достает ранее записанную инструкцию и показывает ее пользователю. Пользователю кажется, что программа остановился на этой инструкции, однако процессор не имеет ни малейшего представления о ее существовании.
	\item Аппаратные точки останова
	
	Внутри большинства процессоров существуют специальные отладочные регистры, которые можно использовать для хранения адресов точек останова и специальных условий доступа, по которым срабатывают эти точки останова (например, на чтение, запись или выполнение). Точки останова, хранящиеся в таких регистрах, называются аппаратными (или процессорными) точками останова. Когда процессор доходит до адреса памяти, которые определен внутри отладочного регистра и выполняются условия доступа, программа останавливается.
\end{enumerate}

В данном курсовом проекте была выбрана технология программных точек останова. 
\section {Выбор вспомогательных библиотек}
\subsection{Библиотека Linenoise}
Библиотека linenoise предназначена для работы в терминале. Она позволяет реализовать автозамену, автодополнение и поддержку истории для ввода команд. Эта библиотека имеет лицензию BSD 2-Clause «Simplified» License.
\subsection{Библиотека Libelfin}
Библиотека Libelfin разработана пользователем aclements.
Она предназначена для чтения бинарных файлов ELF и отладочной информации DWARF.

Стандартные средства разработки компилируют программу в файл ELF (Executable and Linkable Format) с возможностью включения отладочной информации.
Исполняемый файл формата ELF состоит из таких частей:
	\begin{itemize}
	\item Заголовок (ELF Header)
	
	Содержит общую информацию о файле и его основные характеристики.
	\item Заголовок программы (Program Header Table)
	
	Это таблица соответствия секций файла сегментам памяти, указывает загрузчику, в какую область памяти писать каждую секцию.
	\item Секции
	
	Секции содержат всю информацию в файле (программа, данные, отладочная информация и т.д)
	У каждой секции есть тип, имя и другие параметры. В секции «.text» обычно хранится код, в «.symtab» — таблица символов программы (имена файлов, процедур и переменных), в «.strtab» — таблица строк, в секциях с префиксом «.debug» — отладочная информация и т.д. Кроме того, в файле должна обязательно быть пустая секция с индексом 0.
	\item Заголовок секций (Section Header Table)
	
	Это таблица, содержащая массив заголовков секций.\\
    \end{itemize}

	DWARF — это стандартизованный формат отладочной информации.
	Отладочная информация позволяет:
	устанавливать точки останова (breakpoints) не на физический адрес, а на номер строки в файле исходного кода или на имя функции
	отображать и изменять значения глобальных и локальных переменных, а также параметров функции
	отображать стек вызовов (backtrace)
	исполнять программу пошагово не по одной инструкции ассемблера, а по строкам исходного кода.
	
	Эта информация хранится в виде древовидной структуры. Каждый узел дерева имеет родителя, может иметь потомков и называется DIE (Debugging Information Entry). Каждый узел имеет свой тэг (тип) и список атрибутов (свойств), описывающих узел. Атрибуты могут содержать все, что угодно, например, данные или ссылки на другие узлы. Кроме того, существует информация, хранящаяся вне дерева.
	Узлы делятся на два основных типа: узлы, описывающие данные, и узлы, описывающие код.





\section{Дополнительные средства, использованные при разработке:}
\begin{enumerate}
	\item Git и GitHub\\
	Неотъемлемой частью работы с над проектом является использование системы контроля версий, позволяющей разработчикам делегировать работу и параллельно реализовывать разные её части. В качестве такой системы был выбран Git, а веб-сервисом — GitHub, как один из самых популярных и актуальных на данный момент платформ.
	\item Clion\\
	Для работы на С++ хорошо подходит Clion. CLion — это многофункциональная IDE, которая помогает разработчикам C и C++ сосредоточиться на важных элементах кода благодаря автоматическому выполнению стандартных заданий.  CLion поддерживает опции автозавершения кода, настраиваемые стили программирования, использование карт и различных ракурсов и т. д.
	\item Make и Cmake\\
	Make — это система сборки. Она управляет компилятором и другими инструментами сборки для сборки кода. 
	
	CMake — это генератор сборочных систем. Он может создавать Make файлы, он может создавать файлы сборки Ninja, он может создавать проекты KDEvelop или XCode, он может создавать решения Visual Studio. С той же начальной точки, тот же файл CMakeLists.txt. Поэтому, если есть независимый от платформы проект, CMake — это способ сделать его также независимым от системы. 
	\item GNU Compiler Collection\\
	GСС — это свободно доступный оптимизирующий компилятор для языков C, C++. Программа gcc, запускаемая из командной строки, представяляет собой надстройку над группой компиляторов. В зависимости от расширений имен файлов, передаваемых в качестве параметров, и дополнительных опций, gcc  запускает необходимые препроцессоры, компиляторы, линкеры.
\end{enumerate}

\newpage
\chapter{Техническое задание на проект}
\section{Требования к проекту}
\subsection{Функционал программы}
В рамках данной курсовой работы отладчик будет поддерживать следующие функции: 
\begin{enumerate}
	\item Запуск, остановка и продолжение выполнения
	\item Установка точки останова на:
	\begin{itemize}
		\item Адреса памяти
		\item Строки исходного кода
		\item Название функции
	\end{itemize}
	\item Чтение и запись регистров и памяти
	\item Разновидность step методов:
	\begin{itemize}
		\item Step in
		\item Step out
		\item Step over
	\end{itemize}
    \item  Вывод исходного кода отлаживаемого приложения
\end{enumerate} 

\subsection{Взаимодействие с пользователем}
Пользователю предоставляется команда -h (-help). Эта команда передаётся как аргумент в командной строке при запуске приложения. Она выводит краткую информацию по отладчику. Говорит, как корректно его запускать, а так же какие параметры запуска могут использоваться.

\subsection{Cборка приложения}
Правила сборки прописаны в файле CMakeLists.txt
В правилах сборки прописаны пути до файлов с исходным кодом. Они используются для создания исполняемого файла.
Также в этом файле прописаны правила для сборки и подключения к проекту вспомогательных библиотек.

\subsection{Размещение исходных кодов}
В корне проекта находится файл CMakeLists.txt, в котором прописаны правила сборки разработанного приложения
Также там расположены три папки:\\
	\begin{itemize}
	\item /doc — в этой папке находится документация к проекту\\
	\item /lib — в этой папке находится исходный для двух вспомогательных библиотек Linenoise и Libelfin\\
	\item /src — в этой папке находится весь исходный код для разработанного отладчика\\
\end{itemize}
\subsection{Требуемые версии средств сборки}
	\begin{itemize}
	\item gcc — version 7.5.0 
	\item cmake —  version 3.10.2
	\item make — version 4.1
	\item стандарт С++ —  version ++17
\end{itemize}
\subsection{Поддерживаемые форматы отлаживаемых приложений}
	\begin{itemize}
	\item gcc — version 7.5.0 
	\item glibc — 2.27
	\item  DWARF  — 2.0.0
\end{itemize}

\section{Метод реализации технологии отладки}
В разработанном приложении используются программные точки останова, так как они проще и не ограничены по количеству. Программные точки останова устанавливаются путем изменения исполняемого кода. Для этого применяется ptrace, который может использоваться для чтения и записи в память. Вносимые изменения должны вызывать остановку процессора и сигнализировать программе, когда выполняется адрес точки останова. На x86-архитектуре это достигается путем перезаписи инструкции по этому адресу инструкцией int 3.

Int (interrupt) — инструкция на языке ассемблера для процессора архитектуры x86, генерирующая программное прерывание.

INT 3 — команда процессоров семейства x86, которая несёт функцию программной точки останова. Исполнение команды приводит к вызову обработчика прерывания номер 3, зарезервированного для отладочных целей. Команда INT 3 кодируется одним байтом с кодом 0xCC.

Когда процессор выполняет инструкцию int 3, управление передается обработчику прерывания точки останова, который сигнализирует процессу SIGTRAP в Linux.
\subsection{Основные функции}
	\begin{enumerate}
	\item  {\bf main} 
	\begin{figure}[h!]
		\center{\includegraphics[scale=0.6]{1}}
		\caption{}
	\end{figure}
	\newpage
	С функции main начинается выполнение программы. В ней происходит саздание нового процесса с помощью системного вызова fork().это приводит к тому, что программа разделяется на два процесса. 
	\item {\bf fork}\\
	
	Когда выполнение программы происходит в дочернем процессе, fork возвращает 0, иначе - идентификатор дочернего процесса. 
	\item  {\bf execute\_debugee}
	\begin{figure}[h!]
		\center{\includegraphics[scale=0.9]{2}}
		\caption{}
	\end{figure}
	\\
	В функции execute\_debugee происходит вызов ptrace, который указывает, что текущий процесс должен позволить своему родителю отслеживать его. 
	\item  {\bf run} 
	\begin{figure}[h!]
		\center{\includegraphics[scale=0.9]{3}}
		\caption{}
	\end{figure}
	\\
	В функции происходит ожидание сигнала от родительского процесса и инициализация адреса отлаживаемой программы. Далее запускается цикл, в котором запрашиваются команды у пользователя.
	\item {\bf handle\_command} \\
	
	В функции происходит обработка пользовательских команд. 
	\begin{table}[h]
		\begin{center}
			\begin{tabular}{|p{4cm}|p{6cm}|}
				\hline 
				Пользовательские команды & Вызов функций \\ \hline
				cont  & continue\_execution \\ \hline
				break & set\_breakpoint\_at\_address  \\ \hline
				step & step\_in \\ \hline
				next & step\_over \\ \hline
				finish & step\_out \\ \hline
				show & print\_source  \\ \hline
				register write & set\_register\_value  \\ \hline
				register read & get\_register\_value  \\ \hline
			\end{tabular}
		\end{center}
	\end{table}
	\item {\bf continue\_execution}
	\begin{figure}[h!]
		\center{\includegraphics[scale=0.9]{4}}
		\caption{}
	\end{figure}
	\\
	В функции происходит вызов ptrace, чтобы сообщить процессору о продолжении выполнения программы. Затем происходит ожидание сигнала от дочернего процесса. 
	\item  {\bf step\_over} \\
	
	Функция отвечает за шаг с обходом. Концептуально, необходимо поставить точку останова на следующую строку исходного кода. Но это может быть не та строка, если текущее выполнение программы происходит в цикле. По этой причине, необходимо установить точки останова на каждую строку текущей функции. После, продолжить выполнение до последней точки останова и удалить все поставленные точки. 
	\item {\bf step\_out} \\
	
	Данная функция предназначена для выполнения команды “finish”. В функции происходит установка точки останова на адрес возврата, переход на установленную точку и ее удаление. 
	\item {\bf set\_breakpoint\_at\_address}
	\begin{figure}[h!]
		\center{\includegraphics[scale=0.7]{5}}
		\caption{}
	\end{figure}
	\\
	Функция устанавливает точку останова по заданному адресу. Для этого создается новая точка, включается и записывается в массив.
	\item  
	{\bf set\_breakpoint\_at\_source\_line}
	\begin{figure}[h!]
		\center{\includegraphics[scale=0.7]{6}}
		\caption{}
	\end{figure}
	\\
	
	Функция устанавливает точку останова по заданному номеру строки файле с исходным кодом. В функции происходит получение адреса строки и установка точки останова по этому адресу. 
	\item 
   {\bf set\_breakpoint\_at\_function}
   \begin{figure}[h!]
      \center{\includegraphics[scale=0.7]{7}}
      \caption{}
    \end{figure}
     \\

Функция устанавливает точку останова по заданному названию функции. В функции происходит получение адреса функции и установка точки останова по этому адресу.
	\end{enumerate}

\chapter{Пример работы программы}
\noindent Исходный код отлаживаемого приложения: 
\begin{figure}[h!]
	\center{\includegraphics[scale=0.7]{start}}
	\caption{}
\end{figure}

\noindent Старт:
\begin{figure}[h!]
	\center{\includegraphics[scale=1]{Старт}}
	\caption{}
\end{figure}

\newpage 

\noindent Вывод исходного кода:
\begin{figure}[h!]
	\center{\includegraphics[scale=0.8]{вывод}}
	\caption{}
\end{figure}

\noindent Установка точки останова по названию функции:
\begin{figure}[h!]
	\center{\includegraphics[scale=1.2]{Установка точки останова по названию функции}}
	\caption{}
\end{figure}

\newpage 

\noindent Переход на точку останова: 
\begin{figure}[h!]
	\center{\includegraphics[scale=1.2]{Переход на точку останова}}
	\caption{}
\end{figure}

\noindent Step: 
\begin{figure}[h!]
	\center{\includegraphics[scale=1.2]{Шаг}}
	\caption{}
\end{figure}

\newpage 

\noindent Step out:
\begin{figure}[h!]
	\center{\includegraphics[scale=1.2]{step_out}}
	\caption{}
\end{figure}

\noindent Step over: 
\begin{figure}[h!]
	\center{\includegraphics[scale=1.2]{step_over}}
	\caption{}
\end{figure}

\newpage 

\noindent Конец выполнения программы: 
\begin{figure}[h!]
	\center{\includegraphics[scale=1.2]{Конец выполнения программы}}
	\caption{}
\end{figure}

\chapter*{Заключение}
Таким образом, при написании программы были получены необходимые представления об устройстве отладчиков. Также получены навыки работы с системными вызовами ptrace, технологией программных точек останова, и различными вспомогательными средствами, такими как Clion, Cmake и GCC. Эти навыки помогут в дальнейшем при написании и отладке любого кода, а также для анализа работы различных, уже существующих, отладчиков, что позволит значительно улучшить качество будущей профессиональной деятельности.

\chapter*{Источники}
\begin{enumerate}
	\item Ptrace: \url{ https://www.kernel.org/doc/html/latest/powerpc/ptrace.html}
	\item ELF: \url{ http://www.skyfree.org/linux/references/ELF_Format.pdf}
	\item DWARF: \url{ https://dwarfstd.org/doc/dwarf-2.0.0.pdf}
	\item Документация к C++:  \url{https://devdocs.io/cpp/}
	\item Документация к Linux: \url{ https://www.kernel.org/doc/html/latest/}
	\item Библиотека libelfin \url {https://github.com/aclements/libelfin}
	\item Библиотека linenoise \url {https://github.com/antirez/linenoise}
\end{enumerate}
\end{document}